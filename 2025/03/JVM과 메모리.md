#### Runtime Data Area
- 메소드 영역
  - 모든 JVM의 스레드가 공유
  - 클래스, 인터페이스, 메소드, 필드, Static 변수, 상수, 정적 메소드의 바이트 코드
- 힙
  - 모든 JVM의 스레드가 공유
  - 런타임에서 생성된 객체가 위치하는 영역
  - 메소드 영역에 로드해 놓았던 클래스만 생성할 수 있음
  - GC가 작동하는 영역
- 스택
  - 메소드 호출 시 호출의 스택 프레임을 생성하여 저장
    - 메소드 안에서 사용되는 값을 저장하고, 호출한 메소드의 매개 변수, 지역 변수, 리턴 값 및 연산 시 생성되는 값을 임시로 저장
    - 메소드 수행이 끝나면 차례대로 삭제함
- PC 레지스터
  - 스레드가 시작될 때 생성됨
    - 스레드마다 하나씩 가지고 있음
  - 스레드가 어떤 명령을 어떻게 실행할지에 대해 기록, 현재 수행중인 JVM 명령의 주소를 가짐
- 네이티브 메소드 영역
  - JAVA 이외의 다른 언어로 작성된 네이티브 코드를 위한 메모리 영역


- 즉, Thread마다 가지고 있는 영역은 Stack, PC 레지스터, Native Method Stack이고
- 공유하는 영역은 Heap, Method Area임

#### Garbage Collection에서 사용하지 않는 객체를 찾을 떄
- 처음 참조하는 Root 객체를 기준으로 참조하는 객체를 탐색해 나가면서 마킹함
  - 마킹되지 않는 객체는 사용하지 않는 객체로 판단하고 삭제함
  - Root 객체가 되는 기준은 
    - 스레드의 스택에 살아 있는 지역 변수
    - 활성화되어 있는 스레드
    - 클래스 로더로 로드된 클래스 (+ 해당 클래스의 Static 변수)
    - JNI(Java Native Interface)로 생성된 객체

#### JVM에서 실행될때 플로우
- 빌드
  - 컴파일러에 의해서 .java 파일은 .class 바이트코드로 변환됨
    - 바이트 코드는 기계어가 아니므로 실행하기 위해서는 여전히 읽어서 해석하는 과정이 필요
  - 클래스 로더가 바이트코드를 runtime data area에 올림
    - 바이트 코드를 읽어서 적절한 바이너리 데이터를 만들고 변수 및 메소드의 성격에 맞는 영역에 올려준다
      - 메소드 및 static 변수는 메소드 영역에 올려준다
      - 런타임에서 생성된 객체는 힙에 올려준다
      - 런타임에서 실행된 스레드의 수행 정보는 stack에 저장된다
  - executive engine의 interpreter와 jit compiler가 코드 실행 시 해석하여 실행함
    - 인터프리터는 바이트 코드의 명령어를 한 줄 한 줄 읽으면서 실행한다
    - JIT 컴파일러는 자주 사용하는 메소드의 명령어를 컴파일해서 바이너리 코드로 변환해 준다
      - 변환한 다음에는 인터프리터를 안쓰고 바이너리 코드를 가져와서 실행하므로 빨라진다
