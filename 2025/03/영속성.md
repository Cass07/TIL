#### 준영속과 비영속의 차이점??
* 일단 보통 구글링하면 나오는 설명
  * 준영속 : 영속성 컨텍스트에서 관리했다가 분리된 상태
  * 비영속 : 영속성 컨텍스트와 관계가 없는 상태 (엔티티 객체를 생성했고, 생성한 이후로 영속성 컨텍스트와 한 번도 만나지 않은 상태)
* 관리했다가 분리했으면 관계없는 상태 아닌가 ????
  * 아님 준영속 상태는 ID가 있지만 (왜냐하면 영속되면서 반드시 식별자 값을 부여받으니까), 비영속 상태는 ID가 없을 수도 있음 (새로 생성한 엔티티라면)
* 그래도 병합(merge)는 비영속/준영속 엔티티 모두 영속 상태로 만들 수 있음
  * 식별자 값으로 캐시 조회해서 있으면 그걸 반환하고, 없으면 새로 엔티티 생성해서 병합해 주기 때문


#### 영속성 컨텍스트의 특징
* 엔티티를 ID로 구별하기 때문에 반드시 ID 값이 있어야 함 
* 데이터 변경된 것은 컨텍스트가 들고 있다가 커밋할때(flush할때) 실제 DB에 반영됨
  * flush는 영속성 컨텍스트의 변경 내용을 동기화하는 작업
  * 왜 플러시할때 한번에 동기화하느냐?? 플러시할때 트랜잭션 커밋을 하기때문
  * 어차피 트랜잭션 커밋을 해야지 DB에 변경이 적용되니까 실제로 언제 변경쿼리가 생성되었던 간에 커밋 전에만 DBMS로 보내주면 되기때문

#### 장점
* 1차 캐시 : 영속성 컨텍스트 내부에 캐시를 가지고 있어서 영속상태인 애들은 거따 저장중임
  * 그래서 캐시에서 데이터를 먼저 조회해 보고 캐시에 없으면 실제 DB에 조회하기 때문에 db 액세스 중복을 적게할수있다
* 동일성 보장 : 1차 캐시에 의해서 한 번 생성되어 캐시에 저장된 객체는 다음 조회 때 거기서 꺼내오기 때문에, 같은 식별자를 가진 엔티티는 동일한 인스턴스임이 보장된다
* 트랜잭션을 지원하는 쓰기 지연
  * 엔티티를 등록할 때 내부 쿼리 저장소에 Insert문을 순서대로 쌓아놨다가 플러시할때 한꺼번에 쓰기 때문에 트랜잭션을 지원하는 쓰기 지연이 가능
* 변경 감지
  * 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사한 스냅샷을 저장해 둔다
  * 그리고 플러시 시점에 스냅샷과 달라진 엔티티가 있는지 확인한다
  * 달라진 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 내부 쿼리 저장소에 쌓아둔다
  * 이후 플러시할때 같이 써준다
  * 엔티티의 모든 행을 한 번에 업데이트 할 수도 있고, 변경된 부분만 할 수도 있다 (디폴트는 전자)
    * 전자는 미리 수정 쿼리를 생성해 두고 바인딩만 다르게 할 수 있다는 장점
    * 또한 동일한 구조의 쿼리를 ㅏ날리게 되니까, RDBMS에서 쿼리 파싱 트리를 재사용할 수 있다고 한다
    * 후자는 컬럼이 너무 많은 경우에 적합하고, DynamicUpdate (Hibernate의 확장 기능 중 하나)를 사용하면 된다
* 지연 로딩