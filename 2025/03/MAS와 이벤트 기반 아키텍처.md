#### 이벤트 기반 아키텍처란
- 분산된 애플리케이션 서비스가 이벤트를 기반으로 통신하며 동작하는 패턴
  - 서비스 간 결합을 느슨하게 할 수 있거 여러 서비스의 도메인을 분리할 수 있고, 이에 따라 유지보수가 용이해진다
  - 이상적인 EDA란, 각 도메인이 서로에 대해 의존하지 않고, 서로 발행한 이벤트만 가지고 독립적으로 동작할 수 있어야 한다
- 왜 나왔는가? 일반적인 MSA에서의 문제를 해결하기 위해서
  - 서비스 간 직접적으로 통신하며 작업을 수행하게 된다면, 
    - 통신의 명세가 필요하고 변경 시 양 서비스를 수정해야 하며,
    - 네트워크 지연 등에 취약해질 수 있다
  - 여러 서비스 간 트랜잭션을 관리하기 어렵다
  - 서비스가 분산되면 인증 및 인가도 복잡해진다
- 이를 EDA서는 이렇게 해결했다
  - 이벤트 라우터를 통해 서비스 간 통신을 중개하므로, 복잡성이 감소하고, 결합이 느슨하므로 통신 오류의 영향이 줄어든다
  - 이벤트를 통해 데이터를 공유하므로 데이터 일관성 유지가 쉽다
  - 이벤트 라우터를 통해 이벤트를 주고받기 때문에, 서비스가 다른 서비스를 직접 찾을 필요가 없다
  - 이벤트를 기반으로 트랜잭션을 관리할 수 있다

- 이벤트란? 
  - 상태 변화나 조회 등, 서비스에서 발생한 사건
  - 이벤트는 이미 일어난 사건의 기록이므로 변경되지 않는다
  - JSON, XML 등 다양한 포맷으로 표현 가능

#### MSA에서의 이벤트 기반 아키텍처?
- IPC (Inter-Process Communication)
  - 서비스 간 협력을 위한 통신 방법
  - RPC, REST API, gRPC 등 다양한 프로토콜 사용
  - 이벤트 기반인 경우 비동기 방식을 메인으로 사용하기에 서비스 간 결합을 느슨하게 할 수 있다

- MSA의 특성 상 각 서비스별로 별도의 DB를 갖는다
  - 데이터의 일관성 유지가 어려워진다
  - 이를 위해 Saga 패턴을 이용하는데, 
    - 각 서비스의 로컬 트랜잭션이 이벤트를 발행하고, 다른 서버의 DBMS가 이를 구독하여 트랜잭션을 처리하는 방식으로 데이터의 일관성을 유지한다
    - Master-Slave가 트랜잭션 로그를 받아 처리하는 것과 비슷

- 이벤트를 비동기적으로 처리할 수 있도록, pub-sub 패턴을 이용한다
  - 이벤트를 발행하는 Event Producer, 이벤트를 관리하는 Event Brocker, 이벤트를 구독하여 받는 Consumer로 구성

