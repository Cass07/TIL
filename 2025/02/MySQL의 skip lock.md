### Skip Locked
- MySQL 8.0.3 이상부터 지원하는 기능
- 잠긴 행을 건너뛰고, 잠기지 않은 행을 선택하도록 하는 기능
- 동시에 여러 트랜잭션이 같은 행을 수정하지 않게 할 필요성이 있으면서, 잠금이 걸린 행을 순차적으로 대기할 필요가 없을 경우에 유용
  - 티켓팅, 쿠폰 발급 등등
#### 사용법
```sql
CREATE TABLE t (
    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    value VARCHAR(255) NOT NULL,
    issued BOOLEAN NOT NULL DEFAULT FALSE
);

INSERT INTO t (value, issued) VALUES
    ('row1', FALSE),
    ('row2', FALSE),
    ('row3', FALSE);
```
- 트랜잭션 실행 시, `FOR UPDATE SKIP LOCKED`를 사용하면, 잠긴 행을 스킵하고 잠겨있지 않은 행 중에서 선택 가능
  - `SELECT * FROM t WHERE issued = false FOR UPDATE SKIP LOCKED;` 
    - 잠겨있는 row을 제외한 사용 가능한 row만 조회
  - `UPDATE ... SET ... WHERE ... SKIP LOCKED;`
    - 잠겨있는 row를 제외한 사용 가능한 row만 update


### 경매 기록 테이블의 lock 레벨과 종류에 관해서
#### 필요 스펙
- 해당 테이블을 읽기만 하는 비즈니스 로직이 자주 수행하기 때문에, 쓰기를 위한 락을 걸면서 읽기 또한 막아서는 안 된다
- n번째 row를 조회하고, 해당 row의 값을 사용해서 n+1번째 row를 삽입한다
- n번째 row를 조회할 수 있는 사람은 여러 명이여도, n+1번째 row는 제일 처음 사람만 삽입할 수 있다

#### 해결 방법
- named lock
  - 읽기에는 전혀 영향을 주지 않으면서, 쓰기를 실행하는 해당 트랜잭션에서만 lock을 걸고 해제할 수 있음
  - 단, named lock은 MySQL에서만 지원하기 때문에, 데이터베이스 엔진에 종속적
  - 또한, 문자열 길이에 제한이 있기 때문에, named lock에 사용할 문자열을 적절하게 생성해야 할 필요도 있음
  - 그리고 JPQL에서 Named Lock에 대한 별도의 기능이 없으므로, Native Query를 사용해서 직접 원하는 쿼리를 날려야 함

- 다른 방법 : 비관적 락에서 PESSIMISTIC_READ 사용?
  - 다른 트랜잭션에서 읽기를 가능하게 하고, 쓰기만 락을 거는 방법
  - 이 경우라면, 다른 로직에서 데이터를 읽기만 하는 경우에는 문제가 없음
  - 단, 해당 작업의 경우 n번째 데이터를 수정하는 것이 아니라, 해당 값을 읽어서 N+1번째 데이터를 생성하는 것이므로, 읽기 또한 락을 걸 필요가 잆음
    - 읽기 락을 걸 경우, n번째 데이터를 수정해서 n+1번째 데이터를 생성하는 로직이 동시에 실행될 수 있기 때문 
  - 그래서 쓰기 락을 반드시 걸어야 하기 때문에, 비관적 락은 해당 문제에서 사용할 수 없다

- 다른 방법 : 낙관적 락 사용
  - 버저닝 컬럼을 추가해서, 엔티티 수정 시 버전을 조회해서 조회 시점과 수정 시점이 같은 지 체크함
  - 다만 조회 시점과 수정 시점이 달라 롤백이 발생하는 경우가 매우 많다면, 락을 거는 것보다 성능이 떨어질 수 있음
  - 또한 버저닝 컬럼을 추가하고 이를 update하는 약간의 오버헤드가 추가됨