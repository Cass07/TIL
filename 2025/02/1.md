### proxy VS Decorator
- proxy pattern
  - 다른 객체나 메소드에 접근할 때 부가적인 기능을 제공하기 위해서
    - ex) 로깅, 캐싱, 트랜잭션...
  - 객체 생성 시점에 래핑해서 생성하고, 접근할 때 프록시 패턴에서 정의한 메소드가 사용됨
  - 프록시 객체를 대신 생성해서 실제 객체에 접근하고, 두 객체는 같은 인터페이스 구현
- decorator pattern
  - 객체에 동적으로 새로운 책임을 추가하기 위해서
    - 실행 시점에 새로운 기능을 추가할 수 있음
  - 런타임에서 객체에게 새로운 책임을 추가 (객체를 사용하는 코드에 영향을 끼치지 않으면서)
  - 객체와 데코레이터는 같은 추상 클래스 혹은 인터페이스를 구현하고, 생성 시 생성자를 중첩시켜서 생성함
  - 상속을 사용해서 객체의 기능을 추가하기 어려울 때에도 사용

- 즉 두 패턴의 큰 차이점은 
  - 프록시 패턴은 객체의 생성이나 접근에 대한 제어를 위해서
  - 데코레이터 패턴은 런타임에서의 객체의 동적 기능 확장을 위해서

### GraphQL
- API용 쿼리 언어
  - 쿼리 언어란: 정보를 조회하기 위한 query를 작성하기 위해 사용되는 언어
- GraphQL은 클라이언트가 서버로부터 데이터를 조회해 가져오는 것을 목표로 한다

#### 특징
- Http를 통해 요청을 보내고 받는다
- Rest API와 달리, 하나의 endpoint로 모든 데이터를 가져올 수 있다
  - API 개발자가 정의한 필드의 resolver 함수를 통해 데이터를 가져옴
  - 원하는 정보를 한 번의 request로 모두 가져올 수 있다
- 요청을 보낼 때 입력한 쿼리에 따라, 다른 결과를 받을 수 있다
- API에서 정해진 모든 데이터를 return하는 Rest API와 달리, 쿼리를 통해 원하는 데이터만 받을 수 있다
  - Response의 크기를 줄일 수 있음
- 단점
  - query가 복잡해진다면 Rest API보다 요청의 크기가 커질 수 있다
  - 캐싱이 복잡하다
  - 

### gRPC
- 구글의 오픈소스로, HTTP2를 기반으로 한 RPC 프레임워크
- 프로토콜 버퍼 직렬화/역직렬화를 사용해 통신하기에 빠르고 효율적
- proto3 신택스를 사용해 서비스를 정의하고, 이를 사용해 선언형으로 통신 인터페이스 작성 가능
  - 이를 통해 원격 애플리케이션의 메소드를 로컬 메소드처럼 호출해서 사용 가능
- MSA 환경에서 서비스 간 통신을 위해 자주 사용

- 장점
  - 규격만 맞추면 이기종 애플리케이션간 통신이 쉽다
  - 프로토콜 버퍼를 사용하기 때문에, JSON등에 비해 역직렬화/직렬화가 빠르고 용량이 작다
    - 이진형식이라 압축하기 쉬움
- 단점
  - proto 파일이 없다면, 이진형식을 읽을 수 없다
  - 스키마가 변경되면 이를 사용하는 모든 서비스의 proto 파일을 수정해야 한다
    - 사양이 엄격함
