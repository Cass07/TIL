### JUnit의 테스트 종류와 어노테이션에 관해서

#### SpringBootTest
- 사용하는 모든 빈을 등록해서 테스트를 진행
- 실제 서버를 띄우는 것과 같은 효과
- 애플리케이션의 규모가 커지면, 테스트 시간이 증가
- 테스트에 Transactional이 붙어있으면, 테스트가 끝나면 롤백을 해줌

#### WebMvcTest
- Controller를 테스트할 때 보통 사용
- Controller, ControllerAdvice, JsonComponent, Filter, WebMvcConfigureer, HandlerMethodArgumentResolver 만 빈으로 등록
  - 서비스 로직에 대한 검증은, 서비스 클래스의 테스트에서 전담하고, 컨트롤러의 로직만 전담시킨다
  - 해당 컨트롤러에서 위에 해당하지 않는 빈을 사용할 경우, 빈이 등록되지 않아서 테스트에 실패하게 되는데, 이를 방지하기 위해 @MockBean을 사용해서 빈을 등록해줄 수 있다
    - MockBean은 해당 빈을 mock 객체로 만들어서 등록해 주기 때문에, 메소드 정의만 존재하고 구현은 사용자에게 위임하게 된다
    - 따라서 서비스 로직의 테스트에만 집중할 수 있게 된다
- MockMvc를 사용해서, 가상의 요청을 보내는 방식으로 테스트
  - WithMockUser 어노테이션을 사용해서, 가상의 유저를 만들어서 테스트를 진행할 수 있다

#### DataJpaTest
- JPA 관련된 빈만 등록해서 테스트를 진행
- 데이터 소스의 설정이나, CRUD의 테스트를 전담
- 테스트가 끝나면, 테스트에 사용했던 데이터를 롤백함
- `@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)`을 사용해서 `@ActiveProfiles("profile-name")`을 기준으로 테스트 데이터베이스를 설정할 수 있다

#### RestClientTest
- RestTemplate을 사용해서, 외부 API를 호출하는 테스트를 전담

#### 테스트 더블
- 테스트를 위해 사용하는 객체
- 서비스 로직에 대한 테스트 코드를 작성하다 보면, 테스트에 필요한 객체를 생성하는 부분이 복잡해질 수 있음
  - 이를 해결하기 위해, 테스트 더블을 사용해서, 테스트에 필요한 더미 객체를 사용하여 테스트를 진행할 수 있음
- 종류
  - Dummy : 제일 기본적인 테스트 더블로, 내부 기능이 없는 객체
  - Fake : 실제 객체와 비슷하지만, 실제 객체의 기능을 제한적으로 동일하게 구현한 객체
  - Stub : 테스트 중에 호출되는 메소드의 반환값을 미리 정해놓은 객체
  - Spy : Stub와 비슷하지만, 호출된 메소드의 행동을 기록하는 객체
  - Mock : 테스트 중에 호출되는 메소드의 호출 여부나 호출 횟수, 호출 인자 등을 검증하는 객체 (행위를 검증)

- MockBean : 내부 구현이 없는 Mock 객체를 빈으로 등록해서 사용할 수 있게 해주는 어노테이션
  - bean 껍데기만 등록해 주고, 내부 구현은 사용자에게 위임함
  - given() 메소드를 사용해, mockbean이 어떻게 행동할지 정의할 수 있음
```java
@MockBean
private PostRepository postRepository;

// posts 객체를 미리 선언하고, MockBean으로 등록한 postRepository에서 findOne() 메소드를 호출하면 posts 객체를 리턴하도록 테스트를 위해 선언해줌
Post posts = new Post(1L, "title", "content");
given(postRepository.findOne()).willReturn(posts);
```
- SpyBean : 일부 구현만 실제 객체의 것을 사용하는 Spy 빈을 사용할 수 있게 해 주는 어노테이션
  - SpyBean도 given() 메소드를 사용해서, 내부 구현을 따로 정의해줄 수 있음
    - MockBean과는 다르게, given으로 정의한 내용이 아닌 경우, 실제 객체의 메소드를 호출함
  
[참고 링크](https://jojoldu.tistory.com/226)

#### 즉 테스트 클래스의 테스트 책임 분배는?
- 각자의 클래스가 담당하는 작업만 테스트하도록 분리하는 것이 좋다고 생각
  - Repository에서는 데이터베이스 CRUD에 대한 테스트만
  - Service는 비즈니스 로직만
  - Controller에서는 요청과 응답만
  - 자신이 담당하지 않는 부분에 대한 테스트는 담당 클래스에게 위임하고, 테스트 더블을 사용해서 테스트를 진행

### 상속의 이유와 단점?

#### 상속을 사용하는 이유
- 코드의 재사용성을 높이기 위해 (중복되는 코드를 줄일 수 있다)
- 객체지향에서 다형성을 구현하기 위해서

#### 단점
- 캡슐화를 위배할 수 있음 (부모 클래스의 변경이, 자식 클래스에도 영향을 미침)
  - 캡슐화 : 객체의 상태를 외부에서 직접 접근해서 변경하지 못하도록 하는 것
- 상속받는 자식 객체에서의 명확한 사용을 위해, 메소드의 내부를 문서화해야 할 필요가 있음
  - 상속하면서 메소드를 오버라이딩 할 때, 부모의 메소드의 상태를 명확하게 이해해야 의도한 대로 오버라이딩을 할 수 있음
  - 이를 위해서 내부적인 구현을 노출할 수밖에 없게 됨
- 부모 클래스에 결함이 있는 경우, 자식 클래스에도 영향을 미침

