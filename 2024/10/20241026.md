### 컨텍스트 스위칭
- CPU/core에서 실행 중이던 스레드가 다른 스레드로 교체되는 것

#### 컨텍스트?
- 프로세스/스레드의 상태
  - CPU, 메모리, I/O 등의 상태

#### 컨텍스트 스위칭의 이유
- 기본적으로 하나의 코어는 하나의 스레드만 실행할 수 있음
  - 하지만 컴퓨터에서는 여러 개의 프로세스/스레드가 동시에 실행되어야 함
  - 이를 위해 OS는 CPU를 가상화함 (= CPU 타임 셰어링)
    - 하나의 프로세스를 실행하고 중지한 다음 다른 프로세스를 실행하고 중지하는 작업을 반복함
    - 이를 통해 여러 개의 프로세스/스레드가 동시에 실행되는 것처럼 보이게 함
    - 이 과정이 바로 컨텍스트 스위칭

- 프로세스/스레드에 할당된 시간이 초과되어 대기 중인 프로세스/스레드에게 CPU/core 자원을 할당하기 위해
- 프로그램 실행 중 커널 함수를 통해 프로그램을 멈췄을 때 (SIGKILL 등)
- 우선순위가 더 높은 프로세스/스레드가 실행되어야 할 때

#### 컨텍스트 스위칭 과정
- 기본적으로 커널 모드로 전환한 후, CPU register의 값을 PCB를 통해 교체하는 작업이 이루어진다
  - 프로세스간 전환 시에는, 메모리 구조체계가 변경되어야 하므로, MMU(Memory Management Unit)도 새로운 프로세스의 메모리 구조 정보를 바라보도록 해야 하낟
  - 또한 가상 메모리 주소와 실제 메모리 주소의 매핑정보를 가진 TLB(Translation Lookaside Buffer)도 초기화되어야 한다
  - 따라서 프로세스간 전환은 스레드 간 전환보다 자원을 많이 필요로 한다

- 커널 모드 : 컴퓨터의 리소스에 접근할 때, 프로세스에서 커널로 통제권을 넘겨주는 모드
- CPU register : CPU 내부에 있는 데이터 저장 공간
  - 프로세스가 실행되며 그 상태값을 저장하게 된다

##### PCB (Process Control Block)
- 프로세스/스레드의 상태 정보를 저장하는 자료구조
  - 프로세스/스레드 ID
  - 프로세스/스레드 상태
  - 프로그램 카운터
  - CPU 사용량
  - 메모리 사용량
  - I/O 상태 등
##### 프로세스 컨텍스트 스위칭
- 다른 프로세스끼리 스위칭할때 사용
1. 프로세스 1을 실행
2. 컨텍스트 스위칭을 시작 (커널 모드 진입)
3. 프로세스 1의 PCB를 저장
4. 프로세스 2의 PCB를 불러옴
5. 컨텍스트 스위칭 종료 (유저 모드 진입)
6. 프로세스 2를 실행

##### 스레드 컨텍스트 스위칭
- 같은 프로세스 내의 스레드끼리 스위칭할때 사용
1. 프로세스 1을 실행
2. 컨텍스트 스위칭을 시작 (커널 모드 진입)
3. 프로세스 1의 PCB를 저장
4. 프로세스 2의 PCB를 불러옴
5. _MMU가 프로세스 2의 메모리 구조를 바라보도록 변경_
6. _TLB 초기화_
7. 컨텍스트 스위칭 종료 (유저 모드 진입)
8. 프로세스 2를 실행

#### 컨텍스트 스위칭의 오버헤드를 감안하고 스레드를 늘리는 이유?
- 컨텍스트 스위칭은 프로세스의 입장에서는 이득이 존재하지 않는 순수한 오버헤드
- IO Bound 프로세스르 수행하는 경우, IO burst를 기다리는 동안 CPU가 아무런 작업도 수행하지 않고 대기하게 됨
  - IO Bound: IO burst가 긴 프로세스
  - IO burst: 프로세스가 IO 작업을 요청하고 그 결과를 기다리는 시간
  - 이때, 다른 스레드가 CPU를 사용하게 되면, CPU 사용률을 높일 수 있으므로, 오버헤드를 감수하고 스레드를 늘리는 것
