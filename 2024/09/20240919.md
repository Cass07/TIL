## SQL Antipatterns

### 외교관 면책 특권

외교관 면책 특권이란?
- 애플리케이션 개발 규칙이 데이터베이스 개발에는 적용되지 않안다고 가정하는 것
  - 버전 관리 도구를 사용하여 애플리케이션 코드를 관리
  - 자동화된 단위 테스트 또는 기능 테스트 개발 및 실해 
  - 요구 사항, 구현 전략, 운영 및 애플리케이션 유지 관리를 지원하기 위해 문서, 사양, 주석 및 일관된 코드 스타일로 코드를 작성
  
솔루션 
- 대규모 품질 문화 구축
    - 프로젝트 요구 사항 및 산출믈을 서면으로 작성
    - 요구 사항에 맞는 솔류선을 디자인하고 개발
    - 솔루션이 요구 사항과 일치하는지 확인하고 테스트

문서화
- ERD
  - 테이블과 관계를 보여주는 다이어그램 작서 
  - 적절하게 여러 다이어그램으로 분리하여 가독성을 향상
- 테이블, 컬럼, 뷰
  - 테이블에는 엔티티 타입에 대한 설명이 필요
  - 컬럼에는 각 컬럼 값의 의미와, 측정 단위, null에 대한 의미 설명 필요
  - 뷰의 생성 이유, 사용 목적, 업데이트 가능성 등에 대한 명시 필요
- 관계
- 트리거
  - 트리거에서 어떤 비즈니스 규칙을 구현하고 있는지
- 저장 프로시저
  - 프로시저가 해결하는 문제, 입력 및 출력 패러미터의 형식과 의미 등
- SQL 보안
  - 각 사용자에게 어떤 수준의 권한이 적용되어 있는지
  - 불법 인증 시도를 감지하기 위한 수단 등
- 데이터베이스 인프라
  - 브랜드와 버전, 서버 호스트 이름
  - 데이터베이스 서버의 구성 (복제, 클러스터, 프록시, 네트워크 구성 및 포트)
  - 연결 옵션 및 백업 정책
- 객체 관계형 매핑

소스 코드 제어
데이터베이스 디자인 및 변경점을 추적할 수 있도록 변경 사항을 버저닝해야함
- 데이터 정의 스크립트
- 트리거 및 프로시저
- 부트스트랩 데이터
  - 사용자가 데이터를 입력하기 전 데이커베이스의 초기 상태를 나타내는 데이터 세트
- ERD 및 문서
  - 데이터베이스 요구 사항, 구현 및 애플리케이션에서의 사용
- DBA 스크립트
  - 애플리케이션 외부에서 실행되는 데이터 처리 작업

테스트
격리 : 테스트의 중요한 원칙으로 한 번에 시스템의 한 부분만 테스트하도록 함
- 테이블, 컬럼, 뷰
  - 데이터베이스에 존재할 것으로 생각되는 테이블과 뷰가 실제로 존재하는지 테스트
  - 제거한 테이블이나 컬럼이 더 이상 존재하지 않는지 확인
- 제약조건
- 트리거
- 저장 프로시저
- 부트스트랩 데이터
- 쿼리
- ORM 클래스

#### 테이블 및 컬럼 명칭을 변경할 때
기본적으로는 변경하지 않으나 테이블명이 상표 이름과 충돌하거나, 민감한 단어를 사용하거나, 더 이상 사용하지 않는 기술 및  브랜드명을 사용하고 있다면 변경할 필요가 있을 수 있음
1. 변경된 테이블명 혹은 컬럼명으로 테이블 생성
2. 모든 쓰기 작업을 이전 테이블과 신규 테이블에 적용하고, 이외 쿼리 시에는 완전히 최신 데이터가 있는 유일한 이전 테이블만 사용하도록 애플리케이션을 변경하여 배포
3. 이전 테이블의 이전 모든 데이터를 새 테이블로 복사
4. 모든 쓰기 작업을 이전 테이블과 신규 테이블에 적용하는 상태를 유지하고, 쿼리 시 신규 테이블을 사용하도록 애플리케이션을 변경하여 배포
5. 이전 테이블에 대한 쓰기를 중지하도록 애플리케이션을 변경하여 배포
6. 기존 테이블 삭제

### 표준 운영 프로시저
저장 프로시저
- 데이터베이스 자체에 사용자 지정 코드를입력하고 클라이언트 애플리케이션에서 해당 프로시저를 호출하는 방식으로 쿼리하는 SQL의 기능
  
프로시저의 단점
- 데이터베이스 브랜드별로 구문이 다르므로 데이터베이스 변경 시 프로시저 이식에 비용이 많이 든다
- 전용 IDE가 없으므로 디버깅 및 테스트하기 어렵다
- 프로시저에는 배포 전략을 사용할 수 없으므로 프로시저를 업데이트할 시 중단이 이루어질 수 있다
- 프로시저는 데이터베이스 서버에 부하를 발생시키므로 상대적으로 부하가 데이터베이스 서버에 가중된다
- 테이블이 변경된다면 다시 컴파일해야 한다
- 저장 프로시저는 동일한 서버의 데이터에만 액세스할 수 있으므로 `외부 데이터 래퍼`나 `링크드 서버` 를 통해 원격 서버에 있는 데이터에 액세스할 수 없다

장점
- 클라이언트 애플리케이션과 데이터베이스 서버 사이의 네트워크 속도가 느리고, 중간 결과를 얻기 위해 쿼리를 다수 실행할 경우, 이를 저장 프로시저에 구현하면 `네트워크 라운드 트립`으로 인한 대기 시간을 줄일 수 있다
- 클라이언트 애플리케이션 없이도 실행할 수 있다

#### 네트워크 라운드 트립
라운드 트립 타임 (RTT) 라고도 하는듯
인터넷 상에서 송신지부터 목적지까지 패킷이 전송되는데 걸리는 시간
  
애플리케이션 서버의 리소스를 더 활용하고자 한다면, 프로시저 대신 애플리케이션 프로그램 코드에서 더 많은 것을 핸들링할 수 있도록 구현해야 한다

### FK 안티패턴
#### 참조 방향 오류
다대일 관계에서 FK는 다 측인 테이블에서 정의되어야 한다
```sql
CREATE TABLE PARENT (
  parent_id INT PRIMARY KEY
);

CREATE TABLE CHILD(
  child_id INT PRIMARY KEY
  parent_id INT NOT NULL,
  FOREIGN KEY (parent_id) REFERENCES PARENT(parent_id)
)
```

#### 테이블이 생성되기 전에 테이블 참조
테이블을 생성하기 전에 FK가 테이블을 참조하면 오류가 발생한다
#### 참조한 FK가 PK가 아님
FK로 참조한 컬럼이 PK나 Unique KEY 가 아니면 오류가 발생한다

### 복합키의 각 컬럼에 대한 별도의 제약조건 만들기
부모 테이블의 PK에 여러 컬럼이 존재하면서 FK가 각 컬럼에 대한 별도의 제약조건으로 분할되면 오류가 발생한다
부모 테이블에 PK가 여러 컬럼이라면 두 컬럼을 모두 참조하는 하나의 FK를 만들어야 한다
```sql
CREATE TABLE Parent(
    parent_id1 INT;
    parent_id2 INT;
    PRIMARY KEY (parent_id1, parent_id2)
);

CREATE TABLE Child(
    child_id INT PRIMARY;
    parent_id1 INT NOT NULL;
    parent_id2 INT NOT NULL;

    # Wrong
    FOREIGN KEY (parent_id1) REFERENCES Parent(parent_id1);
    FOREIGN KEY (parent_id2) REFERENCES Parent(parent_id2);
    
    # Correct
    FOREIGN KEY (parent_id1, parent_id2) REFERENCES Parent(parent_id1, parent_id2);
)
```

#### 잘못된 컬럼 순서 사용
부모 테이블의 PK에 여러 컬럼이 있다면 FK는 부모 테이블에 정의된 PK 혹은 UK의 순서와 동일해야 한다
오류가 발생하지 않을 수 있지만 행을 추가하지 못할 수 있다

#### 고아 데이터 생성
이미 데이터가 포함된 자식 테이블에 FK를 추가하는 경우, 자식 테이블의 모든 행이 부모 테이블과 일치하는 행을 가지고 있어야 한다

#### 일치하지 않는 문자 조합 사용
부모 테이블과 자식 테이블의 문자 조합이 일치해야 한다

#### Null을 허용하지 않는 컬럼에 SET NULL 옵션 사용
부모 테이블에서 참조된 행을 삭제할 때 해당 FK를 NULL로 갱신해 주는 `ON UPDATE SET NULL` 혹은 `ON DELETE SET NULL` 옵션을 사용하여 FK 제약조건을 정의할 경우, FK 컬럼이 NOT NULL이라면 오류가 발생한다

#### 중복 제약조건 식별자 만들기
제약조건 식별자는 전체 스키마 내에서 고유해야 하며, 중복되게 정의할 경우 오류가 발생한다

#### 호환되지 않는 테이블 타입 사용
자식 테이블과 부모 테이블은 동일한 테이블 타입이여야 한다. 둘 다 영구 베이스 테이블이거나 둘 다 전역 임시 테이블이여야 한다.

### MySql에서의 FK

#### 특정 스토리지 엔진에서만 FK 사용 가능
InnoDB 등의 FK를 지원하는 스토리지 엔진에서만 FK를 정의할 수 있다

#### 대용량 데이터 타입은 FK 지정 불가
CLOB, BLOB, TEXT, JSON 자료형인 컬럼은 PK, UK, FK로 지정할 수 없다. 인덱스 크기가 3072바이트를 넘을 수 없다.  
다른 RDBSM에서는 컬럼의 일부만 잘라서 Prefix 인덱스를 생성할 수 있지만, MySQL은 지원하지 않는다고 한다

#### 고유하지 않은 인덱스에 대한 MySQL FK
InnoDB에서는 비표준으로 고유하지 않은 인덱스도 FK로서 참조할 수 있다. 단 제일 왼쪽 컬러밍여야 한다.

#### 인라인 참조 구문 미지원
MySQL에서는 인라인으로 FK를 정의할 수 없다.
```sql
CREATE TABLE Child(
    child_id INT NOT NULL,
    parent_id int NOT NULL,
    FOREIGN KEY (parent_id) REFERENCES Parent(parent_id)
)
```

### 정규화 규칙
#### 제1정규형
* 테이블이 관계여야 한다
* 테이블에 반복 그룹이 없어야 한다

EX) 하나의 컬럼이 동일한 종류의 2개 이상의 데이터를 가져야 할 경우, 별도의 테이블로 분리해야 하고 동일한 종류의 2개 이상의 데이터는 다른 row에 존재해야 한다


#### 제2정규형
* 제1정규형을 만족하면서, 모든 컬럼이 완전종속관계이다
* 테이블에 복합키가 존재하면서, 컬럼이 여러 복합키 중 부분집합의 키에 종속되어 있다면, 분리해야 한다

EX) 복합키 A, B가 있고 데이터 컬럼 C, D가 있을 떄, C는 A, B 중 A에만 종속된다면 테이블은 ABD, AC로 나누어야 한다

#### 제3정규형
* 제 1, 2 정규형을 만족하면서, 이행적 함수종속 관계를 갖지 않는다

EX) 컬럼 A, B, C가 있으면서, A와 B가 종속, B와 C가 종속관계라면, 테이블은 AB, BC로 분리해야 한다

#### Boyce-Codd 정규형
* 제3정규형의 약간 더 강력한 버전
* 제 3정규형에서 키와 아닌 모든 속성이 테이블의 키에 종속되어야 한다

#### 제4정규형
* Boyce-Codd 정규형을 만족한다
* 다치종속이 없어야 한다 (=복합 PK가 없어야 한다)

EX) 컬럼 ABC가 있으면서, A->B, A->C 관계가 존재한다면, 테이블은 AB, AC로 나누어야 한다

#### 제5정규형
* 제4정규형을 만족한다
* 더 이상 비손실 분해를 할 수 없어야 한다
* 분리한 릴레이션을 조인했을 떄 데이터 손실이 없고 중복 데이터가 생기지 않아야 한다
* Boyce-Codd를 만족하고 복함 PK가 없다면 제5정규형을 만족한다
