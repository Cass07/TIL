### 분산락
- 하나의 DB를 사용하는 애플리케이션의 경우, 해당 DB에서 제공하는 Lock을 이용하면 동시성 제어를 할 수 있음
- 그러나 두 개 이상의 DB를 사용하는 분산 DB 환경이라면, 이러한 방법으로 동시성 제어를 하기 어려움
  - 분산 DB에서 비관적 락을 사용하면, 두 DB 간의 락을 걸기 위해 네트워크 통신이 필요하게 되어, 성능이 떨어짐
  - 두 DB간 동기화 때문에 데드락이 발생할 수 있음
  - 네트워크 파티션 등으로 인해 두 DB 간의 통신이 끊어지면, 서로간 락에 대한 정보를 주고받을 수 없으므로, 데이터 불일치가 발생할 수 있음
  - 한 노드에서 락을 걸고 이 정보가 전파되는 동안, 다른 노드에서 해당 락의 데이터에 접근이 가능하여, 락을 걸었음에도 동일한 데이터에 여러 사용자가 접근할 수 있음
- 이러한 문제를 해결하기 위해 사용하는 것이 분산 락임
  - 즉 DB에 직접 락을 걸어 동시성 제어를 하는 것이 아니라, 다른 환경에서 락을 관리하고 락을 획득한 스레드만 DB에 접근시켜주는 방법
  - 분산 락이라는 개념이 특정한 락/서비스를 의미하는 게 아니라, 분산 환경에서 락을 관리하기 위한 방법론을 의미하는 듯?

#### 분산락을 구현하는 방법들
1. MySQL의 네임드 락
   - 원하는 문자열을 락 이름으로 명시하여 사용할 수 있는 락
2. Redis의 분산 락
   - Redis의 `SET NX` 명령어를 사용하여, 키가 존재하지 않을 때만 값을 설정하는 방식으로 분산 락을 구현
3. Zookeeper의 분산 락
4. etcd, Consul 등의 분산 락

#### 분산락에 사용되는 락의 종류
- 스핀락
  - 멀티스레드 환경에서 공유 자원에 대한 동시 접근을 제어하기 위한 락
  - 락을 획득할 때까지 계속해서 반복문을 돌면서 락을 획득하는 방식이라, 스핀 락이라고 부름
  - 장점
    - 스핀락이 락을 얻기 위해 대기하는 동안 스레드는 활성 상태를 유지하기 때문에 컨텍스트 스위칭이 발생하지 않음
      - 즉, 락을 획득하고 해제하는 그 시간이 짧은 경우, 효율적임
  - 단점
    - 락을 얻지 못하는 경우, 계속해서 반복문을 돌면서 락을 획득하려고 하기 때문에, CPU를 계속해서 사용하게 됨
    - 우선순위 역전 문제가 발생할 수 있음 : 높은 우선순위의 스레드가 낮은 우선순위에 밀려 계속 락을 획득하지 못할 수 있음
- 네임드 락
  - 원하는 문자열을 락 이름으로 사용하여, 여러 스레드 사이에서 동시 접근을 제어
  - 장점
    - 테이블에 직접 락을 걸지 않고 메모리를 이용해서 락을 관리하기 때문에, 그냥 비관적 락을 사용하는 것보다 처리량이 높음
    - MySQL을 이미 사용하고 있다면, 분산락을 위한 추가적인 인프라를 구축하고 관리할 필요가 없음
  - 단점
    - 락을 관리하는 것이 MySQL이므로, DB에 부하가 증가할 수 있음 (그러나 대부분의 경우 그 영향은 크지 않다고 함)
    - MySQL에서만 사용 가능하고, 이를 위해서는 Native Query를 사용해서 네임드 락을 걸고 푸는 코드를 작성해야 함
    - 네임드 락과 테이블 락을 혼용할 경우 데드락이 발생할 수 있음
    - 락을 획득한 뒤에 커넥션을 종료하면 잠금이 해제된다고 한다
    - 네임드 락을 관리하면서 추가로 커넥션 풀을 사용하므로, 커넥션 풀이 부족해질 수 있다

#### 레디스의 분산락
- 레디스는 싱글 스레드로 동작하는 인 메모리 데이터베이스이므로, 단일 레디스 노드를 구축해 사용하면 동시성 문제가 발생하지 않는다
- `SET NX` 명령어를 사용하여, 키가 존재하지 않을 때만 값을 설정하는 방식으로 분산 락을 구현
  - `SET key value NX PX 30000` : 30초 동안만 유효한 키를 생성하는데, 키가 존재하지 않을 때만 값을 저장
  - `DEL key` : 키를 삭제
    - DEL의 경우 잠금을 획득하지 않은 스레드도 잠금을 해제할 수 있기 때문에, KEY가 존재하며, 키에 저장된 값이 클라이언트의 값과 일치하는 경우에만 해제하도록 해야 함
- 단, 단일 레디스 노드라면, 장애 발생 시 락을 관리할 수 없게 된다
  - 이를 해결하기 위해서는 Master-Slave 복제로 클러스터를 구축하면 되는데, 복제는 비동기식이므로 복제의 시간 차이에 따라 역시 race condition이 발생할 수 있음
- 이를 보완하기 위해 나온 것이 Redlock 알고리즘
- Redlock 알고리즘
  - 여러 레디스 노드에 락을 걸어, 락을 획득하는 노드가 과반수 이상이면 락을 획득하도록 하는 알고리즘
    - 현재 시간을 ms 단위로 가져온 뒤, 모든 인스턴스에서 순차적으로 잠금을 시도
    - 클라이언트는 잠금을 획득하기 위해 경과한 시간을 계산하고, 과반수 이상의 레디스 인스턴스에서 잠금을 획득했고, 총 경과 시간이 잠금 유효 시간보다 적다면 분산락을 획득한 것으로 간주
    - 분산락을 획득하지 못한 경우, 모든 인스턴스에서 잠금을 해제하려고 시도
  - 락을 획득하는 데에 실패했다면, 모든 인스턴스에서 해제한 뒤에 다시 시도해야 하므로 random interval을 두고 재시도하게 됨
  - 장점
    - 멀티 클러스터 환경에서 락을 관리할 수 있음
  - 단점
    - clock drift에 취약함
      - 레디스 노드 간의 시간 차이가 발생하면, 두 개 이상의 클라이언트가 동시에 락을 획득할 수 있게 된다
    - 락을 획득한 후 프로세스가 중단되어서 락이 만료되고 또 다른 프로세스가 락을 획득한다면, 동시성 이슈가 발생할 수 있다
      - 이를 해결하기 위한 방법이 쓰기 요청에 version number를 부여하여, 락을 획득할 때 version number를 함께 저장하는 방법이 있다고 하나, Redlock에는 해당 기능이 없다

#### Redission을 사용할 때의 분산락
- Spring 환경에서의 Redis의 기본 클라이언트로는 Lettuce, Jedis 가 있는데, 이 둘을 사용한다며녀 분산락을 직접 구현해서 사용해야 한다
- Redission은, RLock이라는 Lock 전용 객체를 지원하고, Spin lock이 아니라 pub-sub를 사용
  - 락이 해제되면, 해당 락을 subscribe하는 클라이언트에게 락이 해제되었다는 메시지를 보내고, 락을 획득하려는 클라이언트는 해당 메시지를 받아서 락을 획득하게 된다
  - 그래서 별도로 락을 획득하려고 계속 시도하지 않아도 되기 때문에, 스핀 락의 단점을 보완할 수 있다
