### 서블릿이란? 한마디로 정리하면
동적 웹 페이지를 만들기 위한, 자바의 웹 애플리케이션 프로그래밍 인터페이스로, 클라이언트의 요청을 받아서 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술

### JSP란?
Java Server Pages의 약자로, HTML 내부에 JAVA 코드를 삽입할 수 있는 서블릿 기술이다. JSP 파일은 내부적으로 서블릿으로 변환되어 실행된다.

### Fetch join의 단점은?
- join 대상에게 별칭을 줄 수 없다
  - 별칭을 줄 수 없으므로 select, where, 서브쿼리는 사용이 불가능하다
  - 왜냐하면? 엔티티 객체는 DB와 일관성을 유지해야 하기 때문
    - EX: Team 객체가 여러 member1~3 객체를 가지고 있을 때, 검색에서 member 1~2만 조회하도록 조건을 걸어 버리면, member1~2만 가진 team 객체가 생성되어 버린다
    - 이는 DB에서의 값과 다르므로, 엔티티 객체의 일관성이 깨진다
    - 이 상태에서 dirty checking등으로 인해 엔티티 객체를 DB에 반영하려고 하면, member3의 값이 없어질 가능성도 존재한다
    - (이런 경우에는, 엔티티로 조회하는 것이 아니라 DTO로 튜플을 만들어서 값 그 자체만 조회해햐 한다)
- 두 개 이상의 Collection으로 정의된 연관 관계 대상과는 fetch join을 사용할 수 없다
  - fetch join이라는게 결국 JOIN이기 때문에, 일대다 관계를 2개 이상 join하면 당연히 결과 컬럼 수는 카테시안 곱이 된다 (연관관계 1이 1:2고 2가 1:3이였다면, 결과 컬럼 수는 2 * 3 = 6)
  - 그런데 Collection이 중복을 가능하게 한다? 카테시안 곱으로 늘어난 중복된 결과를 정리할 수 없음...
  - 그래서 `MultipleBagFetchException`이 발생한다
  - 그렇기 때문에 중복을 허용하지 않는 자료형인 `SET` 같은 자료형으로 정의된 연관 관계는 두 개 이상의 일대다 관계여도 fetch join을 사용 가능
- Paging 처리가 불가능하다
  - 사실 아예 불가능한건 아닌데, OOM이 발생할 수 있다 (일대다 관계라면)
  - 일대다 관계를 맺고 있다면, n~m번째 데이터를 필요로 한다면, 페이징 처리 시 모든 데이터를 메모리에 올리고, 그 중 n~m번째 데이터를 가져와야 한다
  - 그런데 일대다 관계를 맺고 있다면, 결과 데이터의 수는 객체의 수보다 훨씬 많아질 가능성이 생기기 때문
  - 이 경우에는 fetch join 대신 batchSize를 사용해야 한다
    - 원하는 객체만 먼저 조회해서 페이징하고, 연관관계의 테이블은 IN 쿼리로 조회하는 방식이니까
- 엔티티의 중복을 제거하는 과정에서 distinct 키워드가 들어간다
  - 일대다 관계를 가질 경우, JOIN을 사용하기 때문에 엔티티에 중복이 발생하게 된다
  - 이것을 처리하기 위해서, fetch join을 하면 실제로는 `select distinct t from Team join fetch t.members`와 같은 쿼리가 실행된다
  - distinct... 인덱스를 제대로 못 타면 임시 테이블에 모든 결과를 넣어놓고 중복을 제거하기 때문에, 성능저하 이슈가 발생할 가능성이 있음
  