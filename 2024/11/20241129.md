### INSERT 비즈니스 로직에서의 동시성 제어 트러블슈팅
- 동시성 제어 예시로 많이 사용되는 티켓팅이나 재고 관리 시스템 등에서의 동시성 제어는 어렵지 않음
  - 이 경우에는 내가 제어해야 할 숫자가 DATABASE에 저장되어 있기 때문에 LOCK을 걸 대상이 명확함
  - 위와 같은 경우에서의 비즈니스 로직은 이하의 작업을 하나의 트랜잭션으로 묶으면 됨
    - 수정하고자 하는 ROW : 재고 숫자 데이터가 있는 ROW
    - 현재 재고 숫자를 읽어옴
    - 재고 숫자 ROW에 대한 LOCK 획득
    - 재고를 사용한 데이터를 INSERT (주문 등등...)
    - 재고 숫자 UPDATE
  - 재고 숫자에 대한 LOCK을 걸기 때문에, 위 트랜잭션이 완료되기 전에는 다른 트랜잭션에서 재고 수를 읽을 수 없음
    - 그 경우에는 해당 트랜잭션은 대기하다가 LOCK이 풀리면 다시 실행됨
    - 락을 획득하지 못하는 경우에는 트랜잭션이 롤백되므로 원자성이 보장됨
- 그런데, 여러 INSERT를 시도하는 경우에서의 동시성 제어는 어떻게 트랜잭션을 묶어야 하지??

### 비즈니스 로직 정리
1. 새로운 상품 명을 삽입할 때, 기존에 이미 존재하는 상품명 중에서 중복되서는 안 됨
2. 기존 상품 데이터를 수정할 때, 상품명이 수정된다면, 이미 존재하는 상품명으로는 수정할 수 없음

### 동시성 이슈가 발생할 수 있는 싱황
1. 동시에 같은 상품명을 가진 상품 데이터를 INSERT할 경우
2. 동시에, 같은 상품명을 가진 상품 데이터가 INSERT되면서, 기존 상품명이 수정될 경우
3. 동시에 기존 상품 데이터가 같은 상품명으로 수정될 경우
4. 동시에 상품명 A였던 상품이 B로, B였던 상품이 A로 수정될 경우?

#### Unique Key 제약조건을 이용한 동시성 제어
- 제일 원론적인 방법으로, 중복을 금할 컬럼에 Unique 속성을 부여
  - 동일한 값을 삽입하게 되면, `DuplicateException`이 발생하게 됨
- 장점
  - 비즈니스 로직을 수정할 필요가 없이 제일 간편함
- 단점
  - 중복이 발생하는지 여부를 확인하지 않고 무조건 INSERT 하게 되므로, 중복이 발생할 때마다 Exception이 발생하게 됨
  - 필요없는 Query 호출이 많아짐
- Unique Key 제약조건도 걸되, 비즈니스 로직에서 한번 더 중복 검사를 하는 것이 좋다
#### 비관적 락 사용
- 비관적 락을 사용하여, 동시성 제어를 하는 방법
  - 트랜잭션 내에서 상품명을 조회한 후에 INSERT/UPDATE를 진행하게 되므로, 상품명 조회 시 쓰기 LOCK을 걸면, 트랜잭션이 종료될 때까지 다른 트랜잭션에서는 해당 상품명을 조회할 수 없음
- MySQL에서 Unique key를 설정하면, 중복값을 확인할 때 읽기 락, 데이터를 INSERT/UPDATE할 때는 쓰기 락이 발생한다고 하는데, 중복으로 할 필요가 있나?
  - 그렇다면 내가 추가로 걸면 Deadlock이 발생할 수 있나?

#### DataIntegrityViolationException
- Unique Key 제약조건을 걸어놓은 컬럼에 중복된 값을 INSERT하려고 하면, `DataIntegrityViolationException`이 발생하게 됨
- 다만, JPA는 영속성 컨텍스트를 가지고 있으니까, 우리가 `save()` 메소드를 사용해서 데이터를 저장하더라고, 실제로 Query가 나가는 것은 그 이후가 된다
  - `save()` 하면 1차 캐시에 엔티티 객체를 저장하고 있다가, 이걸 모아서 한번에 DB에 쿼리하니까
- 그래서, INSERT할때 데이터 중복 여부를 바로 확인하려면, 1차 캐시에 가지고 있으면 안 되고 바로 DB에 쿼리를 날려야 한다
  - `flush()` 메소드를 사용해서 강제로 쿼리를 바로 실행시킬 수 있다
    - `saveAndFlush()` 메소드를 사용하면, `save()` 후에 `flush()`를 실행시키는 것과 같다
- 바로 flush하고, `DataIntegrityViolationException`의 경우에는 Exception Handler로 잡아내서 처리하면 좋을 것 같다


#### 즉 결론은
- Unique Key 제약조건은 일단 건다
  - MySQL에서 unique함을 보장하기 위해 알아서 쓰기/읽기 락을 걸어서 처리해 줄 것이다
- 비즈니스 로직은, SELECT를 통해 데이터가 존재하는지 여부를 확인해서 우선적으로 예외처리를 한다
- 동시 호출 등으로 인해서 중복이 발생하면, 비즈니스 로직을 통한 중복 확인은 불가능하다
  - 이 경우에는 Unique Key 제약조건으로 인한 데이터 무결성 제약조건을 위배해서 발생하는 `DataIntegrityViolationException`을 잡아서 처리한다
  - 단 이 경우에는, 어떤 무결성 제약조건을 위배했는지는 stack trace와 에러 메시지를 확인해야만 알 수 있다
    - 따라서 이 경우 애플리케이션에서의 에러 메시지는, 다양한 경우에 대한 에러를 모두 포용할 수 있는 메시지로 리턴해야 한다