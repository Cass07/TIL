## JPA - 하나의 테이블을 두 개 이상의 엔티티에 매핑?
__Copilot Chat 가지고 놀다가 알게된거라 교차검증이랑 테스트 필요__

정규화를 안해서 하나의 테이블이 두 개의 객체로 분리해야 좋을 컬럼을 모두 들고 있으면 어떻게 해야하지??  
하나의 테이블을 두 개 이상의 엔티티로 분리하는 게 가능하다고 함

테이블 구조:
```shell
+----+----+----+----+
| a  | b  | c  | d  |
+----+----+----+----+
| PK |    |    |    |
+----+----+----+----+
```

a, b, c 컬럼을 매핑하는 첫 번째 엔티티
```java
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Id;
import javax.persistence.Column;

@Entity
@Table(name = "table")
public class FirstEntity {
    @Id
    @Column(name = "a")
    private Long id;
    
    @Column(name = "b")
    private String b;
    
    @Column(name = "c")
    private String c;
}
```


a, d 컬럼을 매핑하는 두 번째 엔티티
```java
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Id;
import javax.persistence.Column;

@Entity
@Table(name = "table")
public class SecondEntity {
    @Id
    @Column(name = "a")
    private Long id;
    
    @Column(name = "d")
    private String d;
}
```

데이터 조회하는 데는 당연히! 문제 없음  
단 JPA 특성상 PK는 모든 엔티티가 들고 가 줘야함

### 인덱스 사용은?
복합키 인덱스를 사용할 때에는 복합키의 첫번째 컬럼을 가지고 있지 않으면 JPA에서 조건으로 사용할 수도 없으니까 불가능하다고 한다  
단, 인덱스 스킵 스캔이라는 게 존재하니까 아에 불가능하진 않을 것 같음  
copilot은 복합키 인덱스를 사용할 거면 그냥 필요한 모든 컬럼을 매핑하라고 함  


### INSERT 시에 테이블의 일관성을 유지할 수 없다면?

예시로 `FirstEntity`를 통해 Insert 작업을 요청하는데, 만약 테이블에 `d`컬럼에 `NOT NULL` 제약이 걸려 있으면?  
해당 엔티티를 매핑하는 방법이나, `d`컬럼에 default value를 설정하는 것 이외에도 방법이 있다고 한다  
`@PrePresist` 어노테이션을 사용해서 엔티티가 영속화되기 전에 `d` 컬럼의 default value를 설정하면 된다고 함  

```java
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Id;
import javax.persistence.Column;

@Entity
@Table(name = "table")
public class FirstEntity {
    @Id
    @Column(name = "a")
    private Long id;
    
    @Column(name = "b")
    private String b;
    
    @Column(name = "c")
    private String c;
    
    @Transient
    private String dValue;
    
    @PrePersist
    public void prePersist() {
        if(dValue == null) {
            this.dValue = "default_value";
        }
    }
}
```

- PrePersist? : 엔티티가 영속화되기 전에 호출되는 메소드
- Transient? : 엔티티의 컬럼으로 매핑되지 않는 필드에 사용하는 어노테이션. 주로 비즈니스 로직에서만 사용되는 임시 데이터나, 계산된 값을 저장하기 위해 사용한다고 한다  

근데 Column 어노테이션으로 매핑하지 않았는데 D 컬럼에 매칭되는건지 어떻게 암????? 테스트 해봐야할듯 이거 물어보니까 코파일럿 자꾸 헛소리함  
